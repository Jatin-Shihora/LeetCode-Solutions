* Nope, don't thinks so. why ? Becuase, To make so many travels to find path and then take separate time to convert to Binary. Hence we are compromsing both time and space i.e time complexity will be O(n^2) and space O(n) !!!!!
**So lesss go and understand an optimal solution :)**
* So what if we traverse each node... convert..... and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the node is a leaf node i.e both left and right are NULL then we know that our number has successfully formed and we add it to our ans. Booom we got the optimization.
* **Let's see how the space and time is reduce ^_^ :-** The in recursion call is done for all nodes in O(n) both number formation and binary conversion are done in O(1). and the space used will be O(h) for recursion ,where h is the height of the tree.
***
**Code:-**
*DFS call will be like :0*
```
if(root->left == root->right)
val ;
else
sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;
```
*Wan't to do some fun?!! let's do this using ternary operator ~0~*
```
return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));
```
​
**C++ Final Code:-**
```
class Solution {
public:
int sumRootToLeaf(TreeNode* root, int val = 0) {
if (!root) return 0;//base condition
//val = val << 1 | root->val; //Both are same it's just the bit manipulation way
val = (val * 2 + root->val); //using Normal math
return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));
}
};
```
​
**Python Final Code:-**
```
​
```
​
**Time Complexity :** *`O(n)`*
**Space Complexity:** *`O(1)`*
***
***
**Not a pro in coding just doing it for the fun because I like it ;) , If I can improve anywhere please comment below or if you have any doubt feel free to ask.**